package xoric.prism.creator.custom.creators;

import java.util.ArrayList;
import java.util.List;

import xoric.prism.data.types.Point;

class Optimizer implements IOptimizer
{
	private final IOptimizerListener listener;
	private final List<ObjectImages> objects;
	private final ICreatorFrame frame;
	private final int cores;

	private List<Point> visited;
	private volatile int currentThreads;
	private volatile IOptimizerResults bestResult;

	public Optimizer(IOptimizerListener listener, List<ObjectImages> objects, ICreatorFrame frame)
	{
		this.listener = listener;
		this.objects = objects;
		this.frame = frame;
		this.cores = Runtime.getRuntime().availableProcessors();
	}

	private int findHighestDimension()
	{
		int max = 0;

		for (ObjectImages o : objects)
		{
			int m = o.findHighestDimension();
			if (m > max)
				max = m;
		}
		return max;
	}

	public void start() throws InterruptedException
	{
		// find squares that fit all sprites
		frame.setChapter(1);
		List<IOptimizerResults> squares = findSquares();

		// subsequently reduce dimensions of the squares
		frame.setChapter(2);
		startReduction(squares);
	}

	private List<IOptimizerResults> findSquares() throws InterruptedException
	{
		OptimizerThread[] threads = new OptimizerThread[cores];
		int z = findHighestDimension();
		Point size = new Point(z, z);
		List<IOptimizerResults> solutions = new ArrayList<IOptimizerResults>();
		int n = 1;

		do
		{
			frame.setAction("Guessing texture size (trial " + n + " to " + (n + cores - 1) + ")");

			for (int i = 0; i < cores; ++i)
			{
				threads[i] = new OptimizerThread(objects, size, null);
				threads[i].start();

				size.x *= 2;
				size.y *= 2;
			}

			for (int i = 0; i < cores; ++i)
			{
				threads[i].join();

				if (threads[i].wasSuccessful() && solutions.size() < 4)
					solutions.add(threads[i]);
			}
		}
		while (solutions.size() < 4);

		return solutions;
	}

	private synchronized void startReduction(List<IOptimizerResults> squares)
	{
		visited = new ArrayList<Point>();
		currentThreads = 0;
		bestResult = null;

		for (IOptimizerResults s : squares)
		{
			int w = s.getOriginalSize().getX();
			int h = s.getOriginalSize().getY();

			startReductionThread(w - 1, h);
			startReductionThread(w, h - 1);
		}
	}

	private synchronized void startReductionThread(int w, int h)
	{
		if (w == h || w <= 0 || h <= 0)
			return;

		for (Point p : visited)
			if (p.x == w && p.y == h)
				return;

		Point p = new Point(w, h);
		visited.add(p);
		++currentThreads;

		OptimizerThread t = new OptimizerThread(objects, p, this);
		t.start();
	}

	@Override
	public synchronized void onThreadFinished(IOptimizerResults r)
	{
		--currentThreads;

		if (r.wasSuccessful())
		{
			if (bestResult == null || r.isBetterThan(bestResult))
				bestResult = r;

			int w = r.getOriginalSize().getX();
			int h = r.getOriginalSize().getY();

			startReductionThread(w - 1, h);
			startReductionThread(w - 1, h - 1);
			startReductionThread(w, h - 1);
		}
		else if (currentThreads <= 0)
		{
			listener.onOptimizerFinished(bestResult);
		}
	}
}
