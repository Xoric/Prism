package xoric.prism.creator.custom.creators;

import java.util.ArrayList;
import java.util.List;

import xoric.prism.data.types.IPoint_r;
import xoric.prism.data.types.Point;

class Optimizer implements IOptimizer
{
	private final IOptimizerListener listener;
	private final List<ObjectImages> objects;
	private final ICreatorFrame frame;
	private final int cores;

	private IPoint_r minSize;

	private volatile int currentThreads;
	private volatile IOptimizerResults bestResult;

	public Optimizer(IOptimizerListener listener, List<ObjectImages> objects, ICreatorFrame frame)
	{
		this.listener = listener;
		this.objects = objects;
		this.frame = frame;
		this.cores = Runtime.getRuntime().availableProcessors();
	}

	private Point findHighestDimensions()
	{
		Point max = new Point();

		for (ObjectImages o : objects)
			o.findHighestDimension(max);

		return max;
	}

	private static int calcNextPowerOfTwo(int v)
	{
		int m = 1;
		while (v > m)
			m = m << 1;

		return m;
	}

	public void start() throws InterruptedException
	{
		// find squares that fit all sprites
		frame.setChapter(1);
		minSize = findHighestDimensions();
		int z = minSize.getX();
		if (minSize.getY() > z)
			z = minSize.getY();
		z = calcNextPowerOfTwo(z);
		Point size = new Point(z, z);

		List<IOptimizerResults> squares = findSquares(size);

		// subsequently reduce dimensions of the squares
		frame.setChapter(2);
		startReduction(squares);
	}

	private List<IOptimizerResults> findSquares(Point size) throws InterruptedException
	{
		OptimizerThread[] threads = new OptimizerThread[cores];
		List<IOptimizerResults> solutions = new ArrayList<IOptimizerResults>();
		int n = 1;

		do
		{
			frame.setAction("Guessing texture size (trial " + n + " to " + (n + cores - 1) + ")");

			for (int i = 0; i < cores; ++i)
			{
				threads[i] = new OptimizerThread(objects, size, null);
				threads[i].start();

				size.x *= 2;
				size.y *= 2;
			}

			for (int i = 0; i < cores; ++i)
			{
				threads[i].join();

				if (threads[i].wasSuccessful() && solutions.size() < 4)
					solutions.add(threads[i]);
			}
		}
		while (solutions.size() < 4);

		return solutions;
	}

	private synchronized void startReduction(List<IOptimizerResults> squares)
	{
		currentThreads = 0;
		bestResult = null;

		// generate candidates
		List<Point> candidates = new ArrayList<Point>();

		for (IOptimizerResults s : squares)
		{
			int w = s.getOriginalSize().getX();
			int h = s.getOriginalSize().getY();

			startReductionThread(w / 2, h);
			startReductionThread(w, h / 2);
		}
	}

	private void generateCandidates(List<Point> candidates, int w, int h)
	{
		if (w == h || w <= 0 || h <= 0)
			return;

		for (Point p : candidates)
			if (p.x == w && p.y == h)
				return;

		candidates.add(new Point(w, h));
	}

	private synchronized void startReductionThread(int w, int h)
	{
		if (w == h || w <= 0 || h <= 0)
			return;

		for (Point p : visited)
			if (p.x == w && p.y == h)
				return;

		Point p = new Point(w, h);
		visited.add(p);
		++currentThreads;

		System.out.println("starting new thread w=" + w + ", h=" + h + " (now " + currentThreads + ")");

		OptimizerThread t = new OptimizerThread(objects, p, this);
		t.start();
	}

	@Override
	public synchronized void onThreadFinished(IOptimizerResults r)
	{
		--currentThreads;

		System.out.println("thread finished w=" + r.getOriginalSize().getX() + ", h=" + r.getOriginalSize().getY() + " (now "
				+ currentThreads + ")");

		if (r.wasSuccessful())
		{
			if (bestResult == null || r.isBetterThan(bestResult))
				bestResult = r;

			int w = r.getOriginalSize().getX();
			int h = r.getOriginalSize().getY();

			startReductionThread(w / 2, h);
			startReductionThread(w / 2, h / 2);
			startReductionThread(w, h / 2);
		}

		if (currentThreads <= 0)
			listener.onOptimizerFinished(bestResult);
	}
}
