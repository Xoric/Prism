package xoric.prism.server.net;

import xoric.prism.com.ClientLoginMessage;
import xoric.prism.com.Message;
import xoric.prism.com.Token;
import xoric.prism.data.time.PrismClock;
import xoric.prism.data.types.Heap;
import xoric.prism.data.types.IText_r;
import xoric.prism.server.control.IClient0Handler;
import xoric.prism.server.control.ILoopListener;

public class ClientLink0 implements ILoopListener
{
	private final ClientCore core;
	private final PrismClock clock;
	private final IClient0Handler handler;
	private boolean suppressCrashWarning;

	public ClientLink0(ClientCore core, IClient0Handler handler)
	{
		this.core = core;
		this.clock = new PrismClock();
		this.handler = handler;
	}

	public void kick()
	{
		core.kick();
	}

	public PrismClock getClock()
	{
		return clock;
	}

	public ClientCore getCore()
	{
		return core;
	}

	@Override
	public String toString()
	{
		return core.toString() + "/0";
	}

	private void handleMessage(Message m)
	{
		if (m instanceof ClientLoginMessage && m.getToken() == Token.LOGIN)
		{
			ClientLoginMessage lm = (ClientLoginMessage) m;
			byte[] pw = lm.getPassword();

			Heap h = lm.getHeap();
			IText_r acc = h.texts.get(0);

			handler.login(this, acc, pw, h.ints);
		}
		else
		{
			handler.receievedUnexpectedMessage(this, m);
		}
	}

	public void suppressCrashWarning()
	{
		suppressCrashWarning = true;
	}

	@Override
	public void update()
	{
		Exception crash = core.getCrashException();

		if (crash != null)
		{
			if (!suppressCrashWarning)
				handler.clientCrashed(this, crash);
		}
		else
		{
			try
			{
				Message m;
				do
				{
					m = core.getNextMessage();
					handleMessage(m);
				}
				while (m != null);
			}
			catch (Exception e)
			{
				if (!suppressCrashWarning)
					handler.clientCrashed(this, e);
			}
		}
	}
}
