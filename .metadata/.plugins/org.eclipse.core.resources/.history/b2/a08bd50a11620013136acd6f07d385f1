package xoric.prism.scene.lwjgl;

import java.awt.Dimension;
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.List;

import org.lwjgl.LWJGLException;
import org.lwjgl.opengl.Display;
import org.lwjgl.opengl.DisplayMode;
import org.lwjgl.opengl.GL11;
import org.lwjgl.opengl.GL13;
import org.lwjgl.opengl.GL20;
import org.lwjgl.opengl.GL30;

import xoric.prism.data.IFloatPoint_r;
import xoric.prism.scene.IRenderer;
import xoric.prism.scene.IScene;
import xoric.prism.scene.ISceneListener;
import xoric.prism.scene.SceneStage;
import de.matthiasmann.twl.utils.PNGDecoder;
import de.matthiasmann.twl.utils.PNGDecoder.Format;

public class PrismSceneLWJGL implements IScene, IRenderer
{
	private static double width;
	private static double height;

	private float slope;

	private TextureIO texture;

	// Setup variables
	private final String WINDOW_TITLE = "The Quad: Textured";
	private final int WIDTH = 320;
	private final int HEIGHT = 320;
	// Quad variables
	private int vaoId = 0;
	private int vboId = 0;
	private int vboiId = 0;
	private int indicesCount = 0;
	// Shader variables
	private int vsId = 0;
	private int fsId = 0;
	private int pId = 0;
	// Texture variables
	private int[] texIds = new int[] { 0, 0 };
	private int textureSelector = 0;

	public PrismSceneLWJGL()
	{
		slope = 0.5f;
	}

	private static DisplayMode findDisplay(int width, int height) throws LWJGLException
	{
		DisplayMode[] modes = Display.getAvailableDisplayModes();
		DisplayMode result = null;
		int bestDelta = 0;

		for (int i = 0; i < modes.length; i++)
		{
			int delta = Math.abs(modes[i].getWidth() - width) + Math.abs(modes[i].getHeight() - height);
			if (delta < bestDelta || i == 0)
			{
				bestDelta = delta;
				result = modes[i];
			}
		}
		return result;
	}

	/* **************** IScene *************************** */

	@Override
	public List<Dimension> getAvailableResolutions()
	{
		List<Dimension> result = new ArrayList<Dimension>();
		try
		{
			DisplayMode[] modes = Display.getAvailableDisplayModes();
			for (int i = 0; i < modes.length; i++)
				result.add(new Dimension(modes[i].getWidth(), modes[i].getHeight()));
		}
		catch (LWJGLException e)
		{
			result.clear();
		}
		return result;
	}

	@Override
	public void createWindow(int width, int height, boolean isFullScreen)
	{
		try
		{
			DisplayMode mode = findDisplay(800, 600);
			this.width = mode.getWidth();
			this.height = mode.getHeight();
			Display.setDisplayMode(mode);
			Display.create();
		}
		catch (LWJGLException e)
		{
			e.printStackTrace();
		}
	}

	@Override
	public void setFullScreen(boolean fullscreen)
	{
		try
		{
			Display.setFullscreen(fullscreen);
		}
		catch (LWJGLException e)
		{
		}
	}

	@Override
	public void startLoop(ISceneListener listener)
	{
		final int loopInterval = IScene.LOOP_INTERVAL_MS;
		long lastMs = System.currentTimeMillis();
		boolean resumeTimer = true;

		//		GL11.glMatrixMode(GL11.GL_PROJECTION);
		//		GL11.glLoadIdentity();
		//		GL11.glOrtho(0, Display.getDisplayMode().getWidth(), 0, Display.getDisplayMode().getHeight(), 1, -1);
		//		GL11.glMatrixMode(GL11.GL_MODELVIEW);

		/* test */GL11.glMatrixMode(GL11.GL_PROJECTION); // Den richtigen Stack aktivieren
		GL11.glLoadIdentity(); // Die Matrix zurücksetzen

		//		GL11.glEnable(GL11.GL_DEPTH_TEST); // Tiefentest (mit dem Z-Buffer) aktivieren

		// Eine perspektivische Projektion setzen.
		/* keep */
		//		GL11.glFrustum(-1.6, 1.6, -1.2, 1.2, 1.5, 6.5); // Die Near-Clipping-Plane
		// befindet sich in einer
		// Entfernung von 1.5 Einheiten
		// hat die Abmessungen 3.2 * 2.4
		// Einheiten.
		// Die Far-Clipping-Plane ist 6.5
		// Einheiten entfernt.

		//		this.setupQuad();
		try
		{
			texture = new TextureIO(getClass().getClassLoader().getResourceAsStream("E:/Temp/Prism/g1.png"));
			GL11.glTexEnvi(GL11.GL_TEXTURE_ENV, GL11.GL_TEXTURE_ENV_MODE, GL11.GL_REPLACE);
			texture.init();
		}
		catch (IOException e1)
		{
			e1.printStackTrace();
		}

		do
		{
			long currentMs = System.currentTimeMillis();
			int passedMs = (int) (currentMs - lastMs);

			if (passedMs >= loopInterval)
			{
				//				GL11.glRotated(1, 1, 0.2, 0);

				{
					// Clear the screen and depth buffer
					//					GL11.glClear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);

					// set the color of the quad (R,G,B,A)
					//					GL11.glColor3f(0.5f, 0.5f, 1.0f);

					/* keep */
					//					drawGround();
				}

				GL11.glClear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);

				// client returns false if the scene should be closed
				resumeTimer &= listener.requestUpdateScene(passedMs, this);

				// update the scene
				Display.update();
				resumeTimer &= !Display.isCloseRequested();

				// keep track of passed ms
				lastMs = currentMs;
			}
			else
			{
				try
				{
					Thread.sleep(loopInterval - passedMs);
				}
				catch (InterruptedException e)
				{
					e.printStackTrace();
					resumeTimer = false;
				}
			}
		}
		while (resumeTimer);

		// destroy scene
		listener.onClosingScene();
		Display.destroy();
	}

	@Override
	public void setStage(SceneStage stage)
	{
		GL11.glMatrixMode(GL11.GL_PROJECTION);
		GL11.glLoadIdentity();

		switch (stage)
		{
			case GROUND:
				GL11.glFrustum(-0.5, 0.5, -0.5, 0.5, 1.5, 6.5);
				//				GL11.glTranslated(0.0, -0.25, 0.0);
				//				GL11.glScaled(1.5, 1.5, 1.0);
				break;

			case INTERFACE:
				//				GL11.glOrtho(0, width, 0, height, 1, -1);
				GL11.glOrtho(0.0f, 1.0f, 0.0f, 1.0f, 1.0f, -1.0f);
				break;
		}
		//		GL11.glScaled(1.0, -1.0, 1.0);
		GL11.glMatrixMode(GL11.GL_MODELVIEW);
	}

	/* **************** IRenderer *************************** */

	@Override
	public void setColor(float r, float g, float b)
	{
		GL11.glColor3f(r, g, b);
	}

	private float calcZ(float y)
	{
		float z = -1.5f - y * slope;
		if (z > -1.499f)
			z = -1.499f;
		return z;
	}

	@Override
	public void drawPlane(IFloatPoint_r position, IFloatPoint_r size)
	{
		//		GL11.glBegin(GL11.GL_QUADS);

		texture.bind();

		// Draw the vertices
		//		GL11.glDrawElements(GL11.GL_TRIANGLES, indicesCount, GL11.GL_UNSIGNED_BYTE, 0);

		GL11.glBegin(GL11.GL_QUADS);

		float x = -0.5f + position.getX();
		float y0 = position.getY();
		float y = -0.5f + y0;
		float w = size.getX();
		float h = size.getY();
		float zFront = calcZ(y0);
		float zBack = calcZ(y0 + h);

		GL11.glVertex3f(x, y, zFront);
		GL11.glVertex3f(x + w, y, zFront);
		GL11.glVertex3f(x + w, y + h, zBack);
		GL11.glVertex3f(x, y + h, zBack);

		GL11.glEnd();
	}

	@Override
	public void drawObject(IFloatPoint_r position, IFloatPoint_r size, float zOnset)
	{
		GL11.glBegin(GL11.GL_QUADS);

		float x = -0.5f + position.getX();
		float y0 = position.getY();
		float y = -0.5f + y0;
		float w = size.getX();
		float h = size.getY();
		float z = calcZ(y0) + zOnset;

		GL11.glVertex3f(x, y, z);
		GL11.glVertex3f(x + w, y, z);
		GL11.glVertex3f(x + w, y + h, z);
		GL11.glVertex3f(x, y + h, z);

		GL11.glEnd();
	}

	@Deprecated
	public void drawQuadWorld(float x, float y, float w, float h, float zFront, float zBack)
	{
		//		y = 1.0f - y;

		//		float f = (y + 0.7f) * 0.6f;
		//		float f2 = (x + 0.7f) * 0.6f;
		//		setColor(f, f, f2);

		GL11.glBegin(GL11.GL_QUADS);

		GL11.glVertex3f(x, y, zFront);
		GL11.glVertex3f(x + w, y, zFront);
		GL11.glVertex3f(x + w, y + h, zBack);
		GL11.glVertex3f(x, y + h, zBack);

		//		GL11.glVertex3f(x, y - h, zFront);
		//		GL11.glVertex3f(x + w, y - h, zFront);
		//		GL11.glVertex3f(x + w, y, zBack);
		//		GL11.glVertex3f(x, y, zBack);

		GL11.glEnd();
	}

	@Override
	public void drawSprite(float x, float y, float w, float h)
	{
		//		y = (float) (height - y);

		//		setColor((float) Math.random(), (float) Math.random(), (float) Math.random());

		GL11.glBegin(GL11.GL_QUADS);

		GL11.glVertex2f(x, y);
		GL11.glVertex2f(x + w, y);
		GL11.glVertex2f(x + w, y + h);
		GL11.glVertex2f(x, y + h);

		//		GL11.glVertex2f(x, y - h);
		//		GL11.glVertex2f(x + w, y - h);
		//		GL11.glVertex2f(x + w, y);
		//		GL11.glVertex2f(x, y);

		GL11.glEnd();
	}

	@Override
	public void setSlope(float slope)
	{
		this.slope = slope;
	}

	private void checkGLError(String text)
	{
		int errorValue = GL11.glGetError();
		if (errorValue != GL11.GL_NO_ERROR)
			System.err.println("GL-ERROR " + errorValue + ": " + text);
	}

	private int loadPNGTexture(String filename, int textureUnit)
	{
		ByteBuffer buf = null;
		int tWidth = 0;
		int tHeight = 0;

		try
		{
			// Open the PNG file as an InputStream
			InputStream in = new FileInputStream(filename);
			// Link the PNG decoder to this stream
			PNGDecoder decoder = new PNGDecoder(in);

			// Get the width and height of the texture
			tWidth = decoder.getWidth();
			tHeight = decoder.getHeight();

			// Decode the PNG file in a ByteBuffer
			buf = ByteBuffer.allocateDirect(4 * decoder.getWidth() * decoder.getHeight());
			decoder.decode(buf, decoder.getWidth() * 4, Format.RGBA);
			buf.flip();

			in.close();
		}
		catch (IOException e)
		{
			e.printStackTrace();
			System.exit(-1);
		}

		// Create a new texture object in memory and bind it
		int texId = GL11.glGenTextures();
		GL13.glActiveTexture(textureUnit);
		GL11.glBindTexture(GL11.GL_TEXTURE_2D, texId);

		// All RGB bytes are aligned to each other and each component is 1 byte
		GL11.glPixelStorei(GL11.GL_UNPACK_ALIGNMENT, 1);

		// Upload the texture data and generate mip maps (for scaling)
		GL11.glTexImage2D(GL11.GL_TEXTURE_2D, 0, GL11.GL_RGB, tWidth, tHeight, 0, GL11.GL_RGBA, GL11.GL_UNSIGNED_BYTE, buf);
		GL30.glGenerateMipmap(GL11.GL_TEXTURE_2D);

		// Setup the ST coordinate system
		GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_S, GL11.GL_REPEAT);
		GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_T, GL11.GL_REPEAT);

		// Setup what to do when the texture has to be scaled
		GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_NEAREST);
		GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_LINEAR_MIPMAP_LINEAR);

		this.checkGLError("loadPNGTexture");

		return texId;
	}

	private int loadShader(String filename, int type)
	{
		StringBuilder shaderSource = new StringBuilder();
		int shaderID = 0;

		try
		{
			BufferedReader reader = new BufferedReader(new FileReader(filename));
			String line;
			while ((line = reader.readLine()) != null)
			{
				shaderSource.append(line).append("\n");
			}
			reader.close();
		}
		catch (IOException e)
		{
			System.err.println("Could not read file.");
			e.printStackTrace();
			System.exit(-1);
		}

		shaderID = GL20.glCreateShader(type);
		GL20.glShaderSource(shaderID, shaderSource);
		GL20.glCompileShader(shaderID);

		if (GL20.glGetShaderi(shaderID, GL20.GL_COMPILE_STATUS) == GL11.GL_FALSE)
		{
			System.err.println("Could not compile shader.");
			System.exit(-1);
		}

		this.checkGLError("loadShader");

		return shaderID;
	}

	private void setupShaders()
	{
		// Load the vertex shader
		vsId = this.loadShader("E:/Temp/Prism/tex.glsl", GL20.GL_VERTEX_SHADER);
		// Load the fragment shader
		fsId = this.loadShader("E:/Temp/Prism/frag.glsl", GL20.GL_FRAGMENT_SHADER);

		// Create a new shader program that links both shaders
		pId = GL20.glCreateProgram();
		GL20.glAttachShader(pId, vsId);
		GL20.glAttachShader(pId, fsId);

		// Position information will be attribute 0
		GL20.glBindAttribLocation(pId, 0, "in_Position");
		// Color information will be attribute 1
		GL20.glBindAttribLocation(pId, 1, "in_Color");
		// Textute information will be attribute 2
		GL20.glBindAttribLocation(pId, 2, "in_TextureCoord");

		GL20.glLinkProgram(pId);
		GL20.glValidateProgram(pId);

		this.checkGLError("setupShaders");
	}

	private void setupTextures()
	{
		texIds[0] = this.loadPNGTexture("E:/Temp/Prism/g1.png", GL13.GL_TEXTURE0);
		texIds[1] = this.loadPNGTexture("E:/Temp/Prism/g2.png", GL13.GL_TEXTURE0);

		this.checkGLError("setupTexture");
	}
}
