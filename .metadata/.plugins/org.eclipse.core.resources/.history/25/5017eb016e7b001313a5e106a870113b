package xoric.prism.creator.drawer.control;

import java.awt.Graphics;
import java.awt.image.BufferedImage;
import java.io.File;

import javax.imageio.ImageIO;

import xoric.prism.creator.drawer.model.DrawerModel;
import xoric.prism.creator.drawer.model.SpriteNames;
import xoric.prism.data.exceptions.PrismException;
import xoric.prism.data.types.IPath_r;
import xoric.prism.data.types.IPoint_r;
import xoric.prism.world.entities.AnimationIndex;
import xoric.prism.world.entities.ViewAngle;

public class GridGenerator
{
	private final DrawerModel model;
	private int tilesMax;

	public GridGenerator(DrawerModel model)
	{
		this.model = model;
	}

	public void generateAll()
	{
		try
		{
			tilesMax = 0;

			for (AnimationIndex a : AnimationIndex.values())
				generateAnimation(a);

			// find maximum width and calculate height
			IPoint_r tileSize = model.getTileSize();
			int w = findMaxImageWidth();
			int h = tileSize.getY() * images.size();

			// insert animation images
		}
		catch (PrismException e)
		{
			e.code.print();
			e.user.showMessage();
		}
	}

	private void generateAnimation(AnimationIndex a) throws PrismException
	{
		for (ViewAngle v : ViewAngle.values())
			generateAngle(a, v);
	}

	private void generateAngle(AnimationIndex a, ViewAngle v) throws PrismException
	{
		IPath_r path = model.getPath();
		int n = findMaxIndex(a, v);

		if (n > 0)
		{
			IPoint_r tileSize = model.getTileSize();
			int w = tileSize.getX();
			int ws = w * n;
			int h = tileSize.getY();

			BufferedImage img = new BufferedImage(ws, h, BufferedImage.TYPE_INT_ARGB);
			Graphics g = img.getGraphics();

			for (int i = 0; i < n; ++i)
			{
				File file = null;
				try
				{
					file = path.getFile(SpriteNames.getFilename(a, v, n));
					BufferedImage b = ImageIO.read(file);
					g.drawImage(b, i * w, 0, w, h, null);
				}
				catch (Exception e0)
				{
					PrismException e = new PrismException(e0);
					e.setText("There was an error while reading an image.");
					if (file != null)
						e.addInfo("file", file.toString());
					throw e;
				}
			}
			g.dispose();
			images.add(img);
		}
	}

	private int findMaxIndex(AnimationIndex a, ViewAngle v)
	{
		IPath_r path = model.getPath();
		int n = 0;
		boolean b;

		do
		{
			File file = path.getFile(SpriteNames.getFilename(a, v, n));
			b = file.exists();
			if (b)
				++n;
		}
		while (b);

		return n - 1;
	}

	private int findMaxImageWidth()
	{
		int w = 0;

		for (BufferedImage img : images)
		{
			int j = img.getWidth();
			if (j > w)
				w = j;
		}
		return w;
	}
}
