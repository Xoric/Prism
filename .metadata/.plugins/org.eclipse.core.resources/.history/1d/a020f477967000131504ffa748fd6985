package xoric.prism.world.map;

import xoric.prism.data.Point;

public class RoutingLayer implements IMapLayer
{
	private Node[][] nodes;

	public RoutingLayer()
	{

	}

	@Override
	public void setSize(int tilesX, int tilesY)
	{
		if (nodes == null || nodes.length != tilesY || nodes[0].length != tilesX)
			nodes = new Node[tilesY][tilesX];
	}

	public void initialize(Tile[][] tiles)
	{
		setSize(tiles[0].length, tiles.length);

		// create nodes
		for (int iy = 0; iy < nodes.length; ++iy)
		{
			for (int ix = 0; ix < nodes[iy].length; ++ix)
			{
				Node n = new Node(new Point(ix, iy));
				nodes[iy][ix] = n;
			}
		}
		
		// link nodes
		for (int iy = 0; iy < nodes.length; ++iy)
		{
			for (int ix = 0; ix < nodes[iy].length; ++ix)
			{
				
				
				
				
			}
		}
		
		/**
		 * Checks if the given edge is accessible for at least one MoveType and adds the edge to the source-node if so. Returns true if the edge was added.
		 * @param sourceNode
		 * @param targetNode
		 * @param cost
		 * @param crossedNodes
		 *            Nodes that are being crossed (when walking diagonally), may be none
		 * @return boolean
		 */
		private static boolean addEdge(Node sourceNode, Node targetNode, float cost, View8 transitionAngle,
				Node... crossedNodes)
		{
			// calculate the effective MoveCaps for this edge
			// consider crossed nodes' MoveCaps as well
			MoveCaps caps = targetNode.getGround().getMoveCaps();
			if (crossedNodes.length > 0)
			{
				caps = new MoveCaps(caps.toInt()); // copy MoveCaps object
				for (GroundNode n : crossedNodes)
					caps.bitwiseAnd(n.getGround().getMoveCaps());
			}

			// check if any MoveType is available on this edge
			boolean valid = caps.anyIsTrue();

			if (valid) // add this edge if it is accessible for at least one MoveType
			{
				Edge edge = new Edge(targetNode, caps, cost, transitionAngle);
				valid = sourceNode.addEdge(edge);
			}
			return valid;
		}
	}
}
