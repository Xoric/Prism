package xoric.prism.com;

import java.util.concurrent.atomic.AtomicBoolean;

public class MessageList
{
	private class MessageNode
	{
		private final Message message;
		private volatile MessageNode  next;
		
		public MessageNode(Message m)
		{
			this.message = m;
			this.next = null;
		}
	}

	// Kopf der Schlange: hier werden Daten entnommen (Verbraucher)
	private MessageNode kopf;
	private AtomicBoolean verbrauchersperre;
	// Ende der Schlange: hier werden Daten angehängt (Hersteller)
	private MessageNode ende;
	private AtomicBoolean herstellersperre;

	public GeneralizedConcurrentQueue()
	{
		kopf = ende = new MessageNode(null);
		herstellersperre = new AtomicBoolean(false);
		verbrauchersperre = new AtomicBoolean(false);
	}

	public void Hersteller(final T t)
	{
		MessageNode tmp = new MessageNode(t);
		// Warte solange, bis der Wert von 
		// false auf true gewechselt werden konnte.
		while (!herstellersperre.compareAndSet(false, true))
		{
		}
		// Neuen Knoten anhängen
		ende.naechster = tmp;
		ende = tmp;
		// Sperre wieder freigeben
		herstellersperre.getAndSet(false);
	}

	public T Verbraucher()
	{
		// Warte solange, bis der Wert von 
		// false auf true gewechselt werden konnte.
		while (!verbrauchersperre.compareAndSet(false, true))
		{
		}
		Node derNaechste = kopf.naechster;
		if (derNaechste != null)
		{
			// Entnimm das erste Element, sofern vorhanden
			T val = derNaechste.wert;
			derNaechste.wert = null;
			kopf = derNaechste;
			// Sperre wieder freigeben
			verbrauchersperre.getAndSet(false);
			return val;
		}
		verbrauchersperre.getAndSet(false);
		// Schlange war leer...
		return null;
	}
}