package xoric.prism.com;

import java.io.BufferedInputStream;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.net.Socket;

import xoric.prism.data.exceptions.PrismException;
import xoric.prism.data.exceptions.UserErrorText;

public class SocketReader extends Thread
{
	private final BufferedInputStream stream;
	private final byte[] buffer;
	private final ISocketListener listener;

	public SocketReader(Socket socket, ISocketListener listener) throws IOException
	{
		this.stream = new BufferedInputStream(socket.getInputStream());
		this.buffer = new byte[Message.maximumBufferSize];
		this.listener = listener;
	}

	@Override
	public void run()
	{
		try
		{
			listen();
		}
		catch (Exception e)
		{
			listener.onSocketListenerCrashing(e);
		}
	}

	private void listen() throws Exception
	{
		do
		{
			// read next 3 bytes
			int n = stream.read(buffer, 0, 3);
			if (n < 3)
			{
				PrismException e = new PrismException();
				// ----
				e.user.setText(UserErrorText.COMMUNICATION_ERROR);
				// ----
				e.code.setText("header had " + n + " byte(s)");
				// ----
				throw e;
			}

			// check startByte
			if (buffer[0] != Message.startByte)
			{
				PrismException e = new PrismException();
				// ----
				e.user.setText(UserErrorText.COMMUNICATION_ERROR);
				// ----
				e.code.setText("header didn't start with startByte");
				e.code.addInfo("expected", String.valueOf(Message.startByte));
				e.code.addInfo("read", String.valueOf(buffer[0]));
				// ----
				throw e;
			}

			// extract size
			int size = buffer[1] | (buffer[2] << 8);
			if (size < 1 || size > Message.maximumBufferSize)
			{
				PrismException e = new PrismException();
				// ----
				e.user.setText(UserErrorText.COMMUNICATION_ERROR);
				// ----
				e.code.setText("header supplied invalid size information");
				e.code.addInfo("size", String.valueOf(size));
				// ----
				throw e;
			}

			// read actual data
			n = stream.read(buffer, 0, size);
			if (n != size)
			{
				PrismException e = new PrismException();
				// ----
				e.user.setText(UserErrorText.COMMUNICATION_ERROR);
				// ----
				e.code.setText("input dataBuffer from socket was " + n + " instead of " + size + " byte(s)");
				// ----
				throw e;
			}

			// peek tokenIndex
			int tokenIndex = buffer[0];
			ByteArrayInputStream stream = new ByteArrayInputStream(buffer, 0, size);

			// create message
			if (tokenIndex == Token.LOGIN.ordinal())
				handleClientLoginMessage(stream);
			else
				handleCommonMessage(tokenIndex, stream);
		}
		while (true);
	}

	private void handleClientLoginMessage(ByteArrayInputStream stream) throws IOException, PrismException
	{
		ClientLoginMessage m = new ClientLoginMessage();
		m.unpack(stream);
		listener.receiveClientLoginMessage(m);
	}

	private void handleCommonMessage(int tokenIndex, ByteArrayInputStream stream) throws IOException, PrismException
	{
		Token token = Token.valueOf(tokenIndex);
		Message m = new Message(token);
		m.unpack(stream);
		listener.receiveCommonnMessage(m);
	}
}
