package xoric.prism.world.animations;

import xoric.prism.data.meta.MetaBlock;
import xoric.prism.data.meta.MetaLine;
import xoric.prism.data.types.Heap;

/**
 * First eight values are equivalent to {@link xoric.prism.world.movement.MoveType}.
 * @author XoricLee
 * @since 23.03.2012, 11:49:14
 */
public enum AnimationIndex
{
	// the first eight values are equivalent to movement types:
	WALK(true),
	RUN(true),
	SNEAK(true),
	FLY(true),
	SWIM(true),
	DIVE(true),
	// --
	UNUSED0(false),
	UNUSED1(false),

	// idle animations:
	IDLE(true),
	REST(true),
	CROUCH(true),
	HANG(true),
	FLOAT(true),
	FLOW(true),
	// --
	UNUSED2(false),
	UNUSED3(false),
	UNUSED4(false),
	UNUSED5(false),
	UNUSED6(false),
	UNUSED7(false),
	UNUSED8(false),
	UNUSED9(false),
	UNUSED10(false),

	// alternative movement animations:
	SLIDE(true),
	DASH(true),
	JUMP(false),
	// --
	UNUSED11(false),
	UNUSED12(false),
	UNUSED13(false),
	UNUSED14(false),
	UNUSED15(false),
	UNUSED16(false),
	UNUSED17(false),
	UNUSED18(false),
	UNUSED19(false),
	UNUSED20(false),
	UNUSED21(false),
	UNUSED22(false),

	// social animations:
	ALERT(false),
	// --
	UNUSED23(false),	
	UNUSED24(false),	
	UNUSED25(false),	
	UNUSED26(false),	
	UNUSED27(false),	
	UNUSED28(false),	
	UNUSED29(false),	
	UNUSED30(false),	
	UNUSED31(false),	
	UNUSED32(false),	
	UNUSED33(false),	
	UNUSED34(false),	
	UNUSED35(false),	
	UNUSED36(false),	
	UNUSED37(false),	
	UNUSED38(false),	
	UNUSED39(false),	
	UNUSED40(false),	

	// combat animations:
	ATTACK(false),
	CRIT(false),
	CAST(false),
	CONJURE(false),
	BLOCK(false),
	HURT(false),
	STUNNED(true),
	DIE(true),

	// variable animations
	// revised:
	// unsure:
	JUMP_UP(false),
	JUMP_DOWN(false),
	DROP_DOWN(false),
	DROP_LOOP(true),
	STAND_UP(false);

	public static final int COUNT = values().length;
	private static final AnimationIndex[] values = values();

	static
	{
		SNEAK_IDLE.setSubstitute(IDLE);
		WALK.setSubstitute(IDLE);

		//		RUN.setSubstitute(WALK);
		//		SLIDE.setSubstitute(WALK);
		//		RAIL.setSubstitute(WALK);
		//		DRIVE.setSubstitute(WALK);
		//		SWIM.setSubstitute(WALK);
		//		FLY.setSubstitute(WALK);
		//		SNEAK.setSubstitute(WALK);

		CRIT.setSubstitute(ATTACK);
		CAST_TARGET.setSubstitute(ATTACK);
		CAST_OMNI.setSubstitute(CAST_TARGET);
	}

	public static AnimationIndex valueOf(int i)
	{
		return values[i];
	}

	private final boolean loop;
	private AnimationIndex substitute;
	private String description;

	private AnimationIndex(boolean loop)
	{
		this.loop = loop;
		this.description = "";
	}

	public String getDescription()
	{
		return description;
	}

	public boolean isLoop()
	{
		return loop;
	}

	public AnimationIndex getSubstitute()
	{
		return substitute;
	}

	private void setSubstitute(AnimationIndex substitute)
	{
		this.substitute = substitute;
	}

	private static boolean loadDescription(Heap h)
	{
		boolean isOK;
		try
		{
			String s = h.texts.get(0).toString();
			AnimationIndex a = valueOf(s);
			a.description = h.texts.get(1).toString();
			isOK = true;
		}
		catch (Exception e)
		{
			isOK = false;
		}
		return isOK;
	}

	public static boolean loadDescriptions(MetaBlock metaBlock)
	{
		boolean isOK = true;

		for (MetaLine metaLine : metaBlock.getMetaLines())
		{
			Heap h = metaLine.getHeap();
			if (h.texts.size() == 2)
				isOK &= loadDescription(h);
		}
		return isOK;
	}
}
