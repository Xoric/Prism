package xoric.prism.creator.custom.creators;

import java.util.List;

import xoric.prism.data.types.Rect;

class SpritePackerNode
{
	private Rect rect;

	private P occupier = null;

	private Node left = null;

	private Node right = null;

	private Node(Rect r)
	{
		this.rect = r;
	}

	private Rect findRectange(P item)
	{
		if (isLeaf())
		{
			if (item == occupier)
			{
				return rect;
			}
			else
			{
				return null;
			}
		}
		else
		{
			Rect l = left.findRectange(item);

			if (l != null)
			{
				return l;
			}
			else
			{
				return right.findRectange(item);
			}
		}
	}

	private Node insert(int width, int height, P o)
	{
		if (!isLeaf())
		{
			Node r = left.insert(width, height, o);

			if (r == null)
			{
				r = right.insert(width, height, o);
			}

			return r;
		}
		else
		{
			if (occupier != null)
			{
				return null;
			}

			Fit fit = fits(width, height);

			switch (fit)
			{
				case FAIL:
					return null;
				case PERFECT:
					occupier = o;
					return this;
				case FIT:
					split(width, height);
					break;
			}

			return left.insert(width, height, o);
		}
	}

	private boolean isLeaf()
	{
		return left == null;
	}

	/**
	 * Determines if this node contains an item, even many levels below
	 * @return <code>true</code> if this node or any of it's descendants holds an item
	 */
	private boolean isOccupied()
	{
		return occupier != null || !isLeaf();
	}

	/**
	 * Removes an item, and consolidates the tree if possible
	 * @param o
	 *            the item to remove
	 * @return <code>true</code> if the item was found, <code>false</code> otherwise
	 */
	private boolean remove(P o)
	{
		if (isLeaf())
		{
			if (occupier == o)
			{
				occupier = null;

				return true;
			}
			return false;
		}
		else
		{
			boolean found = left.remove(o);
			if (!found)
			{
				found = right.remove(o);
			}

			if (found)
			{
				if (!left.isOccupied() && !right.isOccupied())
				{
					left = null;
					right = null;
				}
			}

			return found;
		}
	}

	private void split(int width, int height)
	{
		int dw = rect.width - width;
		int dh = rect.height - height;

		assert dw >= 0;
		assert dh >= 0;

		Rect r, l;
		if (dw > dh)
		{
			l = new Rect(rect.x, rect.y, width, rect.height);

			r = new Rect(l.x + width, rect.y, rect.width - width, rect.height);
		}
		else
		{
			l = new Rect(rect.x, rect.y, rect.width, height);

			r = new Rect(rect.x, l.y + height, rect.width, rect.height - height);
		}

		left = new Node(l);
		right = new Node(r);
	}

	private Fit fits(int width, int height)
	{
		if (width <= rect.width && height <= rect.height)
		{
			if (width == rect.width && height == rect.height)
			{
				return Fit.PERFECT;
			}
			else
			{
				return Fit.FIT;
			}
		}

		return Fit.FAIL;
	}

	private void getRectangles(List<Rect> rectangles)
	{
		rectangles.add(rect);

		if (!isLeaf())
		{
			left.getRectangles(rectangles);
			right.getRectangles(rectangles);
		}
	}
}